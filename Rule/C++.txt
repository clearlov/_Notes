/**
 * http://google-styleguide.googlecode.com/svn/trunk/cppguide.html
 * This Rule is base on "Code Constitution", and according to Google C++ Guide.
 */
|~ Mutually Exclusive ~| 
* Declaration Order
 
|+ Save source file as .cc and header file as .h +|
The Google style guide suggests saving source file as (.cc). Header files should be self-contained and end in (.h). Files that are meant for textual inclusion, but are not headers, should end in (.inc).
All header files should be self-contained.
If a template or inline function is declared in a .h file, define it in that same file. The definitions of these constructs must be included into every .cc file that uses them, or the program may fail to link in some build configurations. Do not move these definitions to separate -inl.h files.
In general, every source file should have an associated header file. There are some common exceptions, such as unit-tests and small .cc files containing just a main() function.
|[
Unix: C, cc, cxx, c
GNU C++: C, cc, cxx, cpp, c++
Microsoft Visual C++: cpp, cxx, cc
Digital Mars: cpp, cxx
Borland C++: cpp
Watcom: cpp
Metrowerks CodeWarrior: cpp, cp, cc, cxx, c++
]|
|- Exclusion -|
As an exception, a function template that is explicitly instantiated for all relevant sets of template arguments, or that is a private member of a class, may be defined in the only .cc file that instantiates the template.

|+ Related header, C lib, C++ lib, other lib, your header file +|
Use standard order for readability and to avoid hidden dependencies: Related header, C library, C++ library, other libraries' .h, your project's .h.
|[
#include "foo/server/fooserver.h"       // related header files

#include <sys/types.h>                  // C lib
#include <unistd.h>
#include <hash_map>                     // C++ lib
#include <vector>

#include "base/basictypes.h"            // self-defined headers
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
]|
|+ Declaration Order +|
Code Constitution: "Declaration Order: variables, methods; private, protected, public"
Google C++ Guider "Declaration Order" is against Code Constitution, so ignore it.
|[
Typedefs and Enums
Constants (static const data members)
Constructors
Destructor
Methods, including static methods
Data Members (except static const data members)
]|
Friend declarations should always be in the private section. If copying and assignment are disabled with a macro such as DISALLOW_COPY_AND_ASSIGN, it should be at the end of the private: section, and should be the last thing in the class. 

|+ Define functions inline only when they are less than 10 lines +|
|+ When defined a function, parameter order is: inputs, then outputs +|
|+ Namespace +|
Unnamed namespaces are allowed and even encouraged in .cc files, to avoid link time naming conflicts:
Do not use unnamed namespaces in .h files.


|+ Struct only for passive objects; everything else is a class. +|
structs should be used for passive objects that carry data, and may have associated constants, but lack any functionality other than access/setting the data members. Methods should not provide behavior but should only be used to set up the data members, e.g., constructor, destructor, Initialize(), Reset(), Validate().
Make data members private, and provide access to them through accessor functions as needed (for technical reasons, we allow data members of a test fixture class to be protected when using Google Test). Typically a variable would be called foo_ and the accessor function foo(). You may also want a mutator function set_foo(). Exception: static const data members (typically called kFoo) need not be private.
The definitions of accessors are usually inlined in the header file.

|+ All parameters passed by reference must be labeled const. +|
In C, if a function needs to modify a variable, the parameter must use a pointer, eg int foo(int *pval). In C++, the function can alternatively declare a reference parameter: int foo(int &val).
Input parameters may be const pointers, but we never allow non-const reference parameters except when required by convention, e.g., swap().

However, there are some instances where using const T* is preferable to const T& for input parameters. For example:

You want to pass in a null pointer.
The function saves a pointer or reference to the input.
Remember that most of the time input parameters are going to be specified as const T&. Using const T* instead communicates to the reader that the input is somehow treated differently. So if you choose const T* rather than const T&, do so for a concrete reason; otherwise it will likely confuse readers by making them look for an explanation that doesn't exist.


